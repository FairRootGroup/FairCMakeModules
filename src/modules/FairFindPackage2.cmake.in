################################################################################
# Copyright (C) 2018-2021 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  #
#                                                                              #
#              This software is distributed under the terms of the             #
#              GNU Lesser General Public Licence (LGPL) version 3,             #
#                  copied verbatim in the file "LICENSE"                       #
################################################################################

if(CMAKE_VERSION VERSION_LESS 3.12)
  message(FATAL_ERROR "Module FairFindPackage2 requires CMake 3.12 or later!")
endif()

include_guard(GLOBAL)

#
# find_package2(PRIVATE|PUBLIC|INTERFACE|BUNDLED <pkgname>
#               [VERSION <version>]
#               [COMPONENTS <list of components>]
#               [any other option the native find_package supports]...)
#
# Wrapper around CMake's native find_package command to add some features and bookkeeping.
#
# The qualifier (PRIVATE|PUBLIC|INTERFACE|BUNDLED) to the package to populate
# the variables PROJECT_[INTERFACE]_<pkgname>_([VERSION]|[COMPONENTS]|PACKAGE_DEPENDENCIES)
# accordingly. This bookkeeping information is used to print our dependency found summary
# table and to generate a part of our CMake package. BUNDLED decays to PUBLIC if the variable
# <pkgname>_BUNDLED is false and to PRIVATE otherwise.
#
# When a dependending package is listed with ADD_REQUIREMENTS_OF the variables
# <dep_pkgname>_<pkgname>_VERSION|COMPONENTS are looked up to and added to the native
# VERSION (selected highest version) and COMPONENTS (deduplicated) args.
#
# COMPONENTS and VERSION args are then just passed to the native find_package.
#
# The ADD_REQUIREMENTS_OF argument is now a no-op and only remains for compatibility
# reasons. find_package2 now always merges all known requirements.
#
macro(find_package2 qualifier pkgname)
  cmake_parse_arguments(ARGS "" "VERSION" "COMPONENTS;ADD_REQUIREMENTS_OF" ${ARGN})

  string(TOUPPER ${pkgname} pkgname_upper)
  set(__old_cpp__ ${CMAKE_PREFIX_PATH})
  set(CMAKE_PREFIX_PATH ${${pkgname_upper}_ROOT} $ENV{${pkgname_upper}_ROOT} ${CMAKE_PREFIX_PATH})

  # build lists of required versions and components
  unset(__required_versions__)
  unset(__components__)
  if(ARGS_VERSION)
    list(APPEND __required_versions__ ${ARGS_VERSION})
  endif()
  if(ARGS_COMPONENTS)
    list(APPEND __components__ ${ARGS_COMPONENTS})
  endif()
  foreach(req_pkgname IN LISTS PROJECT_PACKAGE_DEPENDENCIES)
    if(${req_pkgname}_${pkgname}_VERSION)
      list(APPEND __required_versions__ ${${req_pkgname}_${pkgname}_VERSION})
    endif()
    if(${req_pkgname}_${pkgname}_COMPONENTS)
      list(APPEND __components__ ${${req_pkgname}_${pkgname}_COMPONENTS})
    endif()
  endforeach()

  # select highest required version
  unset(__version__)
  if(__required_versions__)
    list(GET __required_versions__ 0 __version__)
    foreach(v IN LISTS __required_versions__)
      if(${v} VERSION_GREATER ${__version__})
        set(__version__ ${v})
      endif()
    endforeach()
  endif()
  # deduplicate required component list
  if(__components__)
    list(REMOVE_DUPLICATES __components__)
  endif()

  # call native find_package
  if(__components__)
    find_package(${pkgname} ${__version__} QUIET COMPONENTS ${__components__} ${ARGS_UNPARSED_ARGUMENTS})
  else()
    find_package(${pkgname} ${__version__} QUIET ${ARGS_UNPARSED_ARGUMENTS})
  endif()

  if(${qualifier} STREQUAL BUNDLED)
    if(${pkgname}_BUNDLED)
      set(__qualifier__ PRIVATE)
    else()
      set(__qualifier__ PUBLIC)
    endif()
  else()
    set(__qualifier__ ${qualifier})
  endif()

  if(${pkgname}_FOUND)
    if(${__qualifier__} STREQUAL PRIVATE)
      set(PROJECT_${pkgname}_VERSION ${__version__})
      set(PROJECT_${pkgname}_COMPONENTS ${__components__})
      list(APPEND PROJECT_PACKAGE_DEPENDENCIES ${pkgname})
    elseif(${__qualifier__} STREQUAL PUBLIC)
      set(PROJECT_${pkgname}_VERSION ${__version__})
      set(PROJECT_${pkgname}_COMPONENTS ${__components__})
      list(APPEND PROJECT_PACKAGE_DEPENDENCIES ${pkgname})
      set(PROJECT_INTERFACE_${pkgname}_VERSION ${__version__})
      set(PROJECT_INTERFACE_${pkgname}_COMPONENTS ${__components__})
      list(APPEND PROJECT_INTERFACE_PACKAGE_DEPENDENCIES ${pkgname})
    elseif(${__qualifier__} STREQUAL INTERFACE)
      set(PROJECT_INTERFACE_${pkgname}_VERSION ${__version__})
      set(PROJECT_INTERFACE_${pkgname}_COMPONENTS ${__components__})
      list(APPEND PROJECT_INTERFACE_PACKAGE_DEPENDENCIES ${pkgname})
    endif()
  endif()

  unset(__qualifier__)
  unset(__version__)
  unset(__components__)
  unset(__required_versions__)
  set(CMAKE_PREFIX_PATH ${__old_cpp__})
  unset(__old_cpp__)
endmacro()


#
# Loop over all remaining implicit dependencies and "find_package2" them.
#
macro(find_package2_implicit_dependencies)
  cmake_parse_arguments(ARGS "" "" "EXCLUDE" ${ARGN})

  set(__2_new_implicit__ ON)
  while(__2_new_implicit__)
    set(__2_new_implicit__ OFF)
    foreach(dep IN LISTS PROJECT_PACKAGE_DEPENDENCIES)
      if(NOT dep IN_LIST ARGS_EXCLUDE)
        foreach(implicit IN LISTS ${dep}_PACKAGE_DEPENDENCIES)
          if(    NOT implicit IN_LIST PROJECT_PACKAGE_DEPENDENCIES
             AND NOT implicit IN_LIST ARGS_EXCLUDE)
            set(__2_new_implicit__ ON)
            unset(__2_version__)
            unset(__2_components__)
            if(${dep}_${implicit}_VERSION)
              set(__2_components__ VERSION ${${dep}_${implicit}_VERSION})
            endif()
            if(${dep}_${implicit}_COMPONENTS)
              set(__2_components__ COMPONENTS ${${dep}_${implicit}_COMPONENTS})
            endif()
            if(dep IN_LIST PROJECT_INTERFACE_PACKAGE_DEPENDENCIES)
              set(__2_qualifier__ PUBLIC)
            else()
              set(__2_qualifier__ PRIVATE)
            endif()
            find_package2(${__2_qualifier__} ${implicit} ${__2_version__} ${__2_components__} REQUIRED)
          endif()
        endforeach()
      endif()
    endforeach()
  endwhile()
  unset(__2_qualifier__)
  unset(__2_new_implicit__)
  unset(__2_version__)
  unset(__2_components__)
endmacro()


# Add oneself as PRIVATE package if used from the @PROJECT_NAME@ package
if(@PROJECT_NAME@_FOUND)
  list(APPEND PROJECT_PACKAGE_DEPENDENCIES @PROJECT_NAME@)
endif()


#
# fair_generate_package_dependencies()
#
# From the public dependencies (marked using find_package2)
# generate a snippet (PACKAGE_DEPENDENCIES) that can be
# included in a cmake package *Config.cmake to export the
# needs of the current package
#
function(fair_generate_package_dependencies)
  list(JOIN PROJECT_INTERFACE_PACKAGE_DEPENDENCIES " " DEPS)
  set(PACKAGE_DEPENDENCIES "\
####### Expanded from PACKAGE_DEPENDENCIES by configure_package_config_file() #######

set(${PROJECT_NAME}_PACKAGE_DEPENDENCIES ${DEPS})

")
  foreach(dep IN LISTS PROJECT_INTERFACE_PACKAGE_DEPENDENCIES)
    list(JOIN PROJECT_INTERFACE_${dep}_COMPONENTS " " COMPS)
    if(COMPS)
      string(APPEND PACKAGE_DEPENDENCIES "\
set(${PROJECT_NAME}_${dep}_COMPONENTS ${COMPS})
")
    endif()
    if(PROJECT_INTERFACE_${dep}_VERSION)
      string(APPEND PACKAGE_DEPENDENCIES "\
set(${PROJECT_NAME}_${dep}_VERSION ${PROJECT_INTERFACE_${dep}_VERSION})
")
    endif()
  endforeach()
  string(APPEND PACKAGE_DEPENDENCIES "\

#####################################################################################")
  set(PACKAGE_DEPENDENCIES ${PACKAGE_DEPENDENCIES} PARENT_SCOPE)
endfunction()
